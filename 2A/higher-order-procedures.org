#+TITLE: Lecture 2A: Higher-order Procedures
#+NAME: Fabricio Puente M.
#+DATE: <2025-09-06 Sat>
#+STARTUP: overview

* Introduction
** $\sum^b_{i=a} i$
#+BEGIN_SRC elisp
  (defun sum-int (a b)
    "Return the sum of integer from A to B."
    (if (> a b)
        0
      (+ a (sum-int (1+ a) b))))

  (sum-int 1 10)
#+END_SRC

#+RESULTS:
: 55
+ Divide and Conquer, the second call to ~sum-int~ is a smaller program.
** $\sum^b_{i=a} i^2$
#+BEGIN_SRC elisp
  (defun square (x)
    "Return the square of X."
    (* x x))

  (defun sum-sq (a b)
    "Return the sum of the squares of integers between A and B."
    (if (> a b)
        0
      (+ (square a)
         (sum-sq (1+ a) b))))

  (sum-sq 1 3)
#+END_SRC

#+RESULTS:
: 14
+ Complex systems, we need to divide it in small pieces, each of them we can understand separately.

** PI/8 Leibiniz formula
#+BEGIN_SRC elisp
  (defun pi-sum (a b)
    "Return the aproximation of PI/8 using Leibniz formula.
  The sum start at A and goes until B adding by 4."
    (if (> a b)
        0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))

  (pi-sum 1 1000)
#+END_SRC

#+RESULTS:
: 0.39244908194872286

There is a common patter that emerge from all these examples.
#+BEGIN_SRC elisp
  (defun <name> (a b)
    "Doc string A and B as inputs."
    (if (> a b)
        0
      (+ (<term> a)
         (<name> (<next> a) b))))
#+END_SRC
* Sigma Notation
#+NAME: sigma-notation
#+BEGIN_SRC elisp
  ;; This is the core function. It's a "higher-order" function because
  ;; it takes other functions as arguments (`term` and `next`).
  (defun sum (term a next b)
    "Return a sum by applying TERM to each value from A to B,
    incrementing with the NEXT function."
    (if (> a b)
        0
      ;; Use `funcall` to apply the function stored in `term` to the value `a`.
      (+ (funcall term a)
         ;; This is the recursive call. We use `funcall` again for `next`.
         (sum term
              (funcall next a)
              next
              b))))

  ;; This is a simple identity function.
  (defun identity (x)
    "Return the same input X."
    x)

  ;; This is a wrapper function that sets up the sum for integers.
  ;; It uses the `identity` function for the term and the built-in
  ;; `1+` function for the next step.
  (defun sum-integers (a b)
    "Sum the integers from A to B, inclusive."
    ;; The `#'` is a shorthand for `(function ...)` and tells Lisp
    ;; to treat `1+` as a function to be passed to `sum`.
    (sum #'identity a #'1+ b))

  ;; Example usage:
  ;; (sum-integers 1 10)
  ;; This will sum the integers from 1 to 10.
  ;; The result should be 55.
  (message "The sum of integers from 1 to 10 is: %s" (sum-integers 1 10))
#+END_SRC

#+RESULTS:
: The sum of integers from 1 to 10 is: 55

* Identity
** Leibiniz series for pi/8
#+BEGIN_SRC elisp :eval sigma-notation
  (defun pi/8-sum (a b)
    "Approximates Pi/8 using the Gregory-Leibniz series for terms from A to B.
  Also, it use the generic `sum` procedure."
    (sum (lambda (i) (/ 1.0 (* i (+ i 2))))
         a
         (lambda (i) (+ i 4))
         b))
  (pi/8-sum 1 1000)
#+END_SRC

#+RESULTS:
: 0.39244908194872286

** Iterative implementation of sum
+ This code uses an inner helper function with an accumulator variable to avoid deep recursion.
#+BEGIN_SRC elisp
  ;; This is the main function. It's a "higher-order" function because
  ;; it takes a `term` function and a `next` function as arguments.
  (defun sum (term a next b)
    "Sum the result of TERM applied to values from A to B,
    iterating with the NEXT function."
    ;; We define a local, nested helper function `iter` using `defun`.
    ;; This is the core of the iterative process.
    (defun iter (current-a ans)
      "Iterates to calculate the sum.
      - `current-a`: The current value in the series.
      - `ans`: The running total (the accumulator)."
      ;; The base case: if the current value is greater than the end value,
      ;; return the accumulated answer.
      (if (> current-a b)
          ans
        ;; The recursive step: call `iter` again with the next value and
        ;; a new running total.
        (iter (funcall next current-a)
              (+ ans (funcall term current-a)))))
  ;; Start the iterative process by calling the helper function `iter`.
  ;; The starting value is `a` and the initial accumulator is `0`.
  (iter a 0))

  ;; --- Example Functions for Summation ---

  ;; An identity function that returns its input.
  (defun identity-term (x)
    "Return the same input X."
    x)

  ;; A next function that increments its input by one.
  (defun next-int (x)
    "Return the next integer."
    (1+ x))

  ;; --- Example Usage ---

  ;; Summing the integers from 1 to 10
  (let ((sum-of-integers (sum #'identity-term 1 #'next-int 10)))
    (message "Sum of integers from 1 to 10: %s" sum-of-integers))
#+END_SRC

#+RESULTS:
: Sum of integers from 1 to 10: 55
** Fixed point
#+BEGIN_SRC elisp
  (defun fixed-point (f start)
    "Finds the fixed point of a function F, starting at START.
    A fixed point x is a value for which (funcall f x) equals x."
    (let ((tolerance 0.00001))
      (defun close-enough? (u v)
        "Checks if two numbers are close enough."
        (< (abs (- u v)) tolerance))

      (defun iter (old new)
        "Iterative function to find the fixed point."
        (if (close-enough? old new)
            new
          (iter new (funcall f new))))

      ;; Start the iterative process
      (iter start (funcall f start))))

  (defun sqrt-fixed-point (x)
    "Calculates the square root of x using fixed-point iteration."
    (fixed-point (lambda (y) (/ (+ y (/ x y)) 2.0)) 1.0))

  (sqrt-fixed-point 9.0)
#+END_SRC

#+RESULTS:
: 3.0
** Oscillator
+ ~average-damp~ is a factory for creating new, more stable functions.
#+BEGIN_SRC elisp
  ;; This is the `fixed-point` procedure from before.
  ;; It finds a value for which f(x) = x.
  (defun fixed-point (f start)
    "Finds the fixed point of a function F, starting at START."
    (let ((tolerance 0.00001))
      (defun close-enough? (u v)
        "Checks if two numbers are close enough."
        (< (abs (- u v)) tolerance))

      (defun iter (old new)
        "Iterative function to find the fixed point."
        (if (close-enough? old new)
            new
          (iter new (funcall f new))))

      (iter start (funcall f start))))

  ;; A simple helper procedure to find the average of two numbers.
  (defun average (x y)
    "Returns the average of two numbers."
    (/ (+ x y) 2.0))

  ;; This is the `average-damp` procedure. It takes a function `f`
  ;; and returns a new function.
  (defun average-damp (f)
    "Returns a new procedure that is the average of its argument and (f x)."
    (lambda (x)
      (average (funcall f x) x)))

  ;; The main `sqrt` procedure that uses the others to find the square root.
  (defun sqrt (x)
    "Calculates the square root of x using fixed-point iteration."
    (fixed-point (average-damp (lambda (y) (/ x y))) 1.0))

  ;; --- Example Usage ---

  ;; Calculate the square root of 9
  (let ((my-sqrt (sqrt 9.0)))
    (message "The square root of 9 is: %s" my-sqrt))

  ;; Calculate the square root of 2
  (let ((my-sqrt-2 (sqrt 2.0)))
    (message "The square root of 2 is: %s" my-sqrt-2))
#+END_SRC

* Newton's Method
To find a $y$ such that:
$f(y) = 0$
Start with a guess, $y_0$:
$y_{n+1} = y_n - \frac{f(y_n)}{\frac{df}{dy}}$
+ Whishful thinking is important in engineering.
+ The rights and privileges of first-class citizens.
  - To be named by variables.
  - To be passed as arguments to procedures.
  - To be returned as values of procedures.
  - To be incorporated into data structures.

#+BEGIN_SRC elisp
 ;; ==============================================
;; Part 1: Higher-Order Procedures
;; These are general-purpose procedures that can be reused.
;; ==============================================

(defconst PI-EPSILON 0.0001
  "A small value used for tolerance in calculations.")

(defconst DX 0.0001
  "A small value used for approximating derivatives.")

(defun fixed-point (f start)
  "Find the fixed point of a function F, starting at START."
  (let ((tolerance PI-EPSILON))
    (defun close-enough? (u v)
      "Checks if two numbers are close enough."
      (< (abs (- u v)) tolerance))

    (defun iter (old new)
      "Iterative function to find the fixed point."
      (if (close-enough? old new)
          new
        (iter new (funcall f new))))

    (iter start (funcall f start))))

(defun deriv (f)
  "Approximates the derivative of a function F.
Returns a new function that calculates the derivative at a point X."
  (lambda (x)
    (/ (- (funcall f (+ x DX)) (funcall f x)) DX)))

(defun newton (f guess)
  "Find the root of a function F using Newton's method, starting from GUESS.
Returns a new procedure to find the next iteration."
  (fixed-point (lambda (x)
                 (- x (/ (funcall f x) (funcall (deriv f) x))))
               guess))

;; ==============================================
;; Part 2: Newton's Method for Square Root
;; ==============================================

(defun sqr (x)
  "Return the square of X."
  (* x x))

(defun sqrt-newton (x)
  "Calculates the square root of a number X using Newton's method.
This finds the root of the function f(y) = y^2 - x."
  (newton (lambda (y) (- (sqr y) x)) 1.0))

;; ==============================================
;; Example Usage
;; ==============================================

(message "The square root of 9 is: %s" (sqrt-newton 9.0))
(message "The square root of 2 is: %s" (sqrt-newton 2.0))
#+END_SRC
