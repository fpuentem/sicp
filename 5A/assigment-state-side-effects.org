#+TITLE: Lecture 5A: Assignment, State, and Side-effects
#+AUTHOR: Fabricio Puente Mansilla
#+DATE: <2026-01-17 Sat>
#+STARTUP: indent overview
#+PROPERTY: header-args:elisp :lexical t

* Configuration: Enable Lexical Binding
:PROPERTIES:
:CUSTOM_ID: config-lexical
:END:

*CRITICAL:* The examples in this lecture rely on *Closures* (functions
that remember the variables from where they were defined). Standard
Emacs Lisp uses "Dynamic Scope" by default, which will break these
examples.

To follow along effectively:
1. If you are running these blocks in this Org buffer, the header
   property ~:lexical t~ handles it for you.
2. If you copy code to a scratch buffer, make sure the very first line
   of the buffer is:

~;;; -*- lexical-binding: t -*-~
Then run ~M-x eval-buffer~.

* The Functional Paradigm (Review)
:PROPERTIES:
:CUSTOM_ID: functional-paradigm
:END:

Until now, we have written "Functional Programs". These are encodings
of mathematical truths.
- A function, like ~(factorial 5)~, always returns ~120~.
- It doesn't matter *when* you call it.
- It doesn't matter *how many times* you call it.
- *Substitution Model:* We could understand the program by simply
  replacing names with values.  ~(+ 2 2)~ is interchangeable with ~4~.

#+BEGIN_SRC elisp :results output
  ;; A Functional Program (Truth)
  (defun factorial (n)
    (if (= n 1)
        1
      (* n (factorial (1- n)))))

  (print (factorial 4)) ;; Always 24, forever.
#+END_SRC

* Introducing Assignment (The "Time" Factor)
:PROPERTIES:
:CUSTOM_ID: introducing-assignment
:END:

Today, we introduce a "horrible" thing: *Assignment*.
In Scheme, this is ~set!~. In Elisp, we use ~setq~ (set quoted variable).

*The Consequence:* Once we introduce assignment, a variable is no longer
just a name for a value. It becomes a **place** where a value is stored,
and that value can change.

This introduces *Time* into our programs.
- "After" the assignment, variable $x$ is 4.

- "Before" the assignment, variable $x$ was 3.

*Code Example: The Breakdown of Substitution* Here is a function ~demo~
that returns different results for the same input.

#+BEGIN_SRC elisp :results output
  (defvar *count* 1) ;; Global variable (State)

  (defun demo (x)
    (setq *count* (1+ *count*)) ;; SIDE EFFECT: Change the world
    (+ x *count*))

  (print (format "First call: %d" (demo 3)))
  (print (format "Second call: %d" (demo 3)))
#+END_SRC

*Observation:*
- Call 1: ~(demo 3)~ -> Returns 5 (3 + 2)

- Call 2: ~(demo 3)~ -> Returns 6 (3 + 3)

*Why is this a problem?* The Substitution Model is dead. If we tried to
replace ~(demo 3)~ with its value, which value do we pick? 5? 6? We can
no longer reason about the code just by looking at the text. We must
know the *history* of the execution.

* The Environment Model (Crucial Theory)
:PROPERTIES:
:CUSTOM_ID: environment-model
:END:

Since the substitution model fails, we need a new mental model to
understand how Lisp executes code with state. This is called the
*Environment Model*.

** Key Terminology
1. *Frame:* A table of variable bindings (e.g., ~{x: 3, y: 5}~).
2. *Environment:* A sequence of frames. It starts with a specific frame
   and points to a "Parent" environment.
3. *Binding:* The association of a name to a value within a frame.
4. *Shadowing:* If a variable ~x~ exists in the current frame and the
   parent frame, the inner one "shadows" (hides) the outer one.

** The Two Rules of Evaluation
There are only two rules you need to memorize for the Environment Model:

*Rule 1: Procedure Application (Calling a function)*
To apply a procedure to arguments:
1. Create a *New Fframe*.
2. Bind the formal parameters (arguments) to the actual values in
   that frame.
3. Link this new frame to the *Environment where the procedure was
   DEFINED* (not where it was called!).
4. Evaluate the body in this new environment.

*Rule 2: Lambda Evaluation (Creating a function)*
When a ~lambda~ is evaluated to create a procedure:
1. It creates a procedure object (a "double bubble").
2. One part points to the code.
3. The other part points to the *Current Environment*.
*This is how a function "remembers" variables like ~balance~ or ~count~.*

* Local State & Encapsulation
:PROPERTIES:
:CUSTOM_ID: local-state
:END:

We want to bundle state *inside* an object so that it doesn't pollute
the global world. This creates an **Object**.

In the video, Sussman creates ~make-counter~.

#+BEGIN_SRC elisp :results output
  ;; Factory function
  (defun make-counter (n)
    ;; Returns a Lambda.
    ;; Because of Lexical Binding, this Lambda 'captures' the specific 'n' frame.
    (lambda ()
      (setq n (1+ n))
      n))

  ;; Create two INDEPENDENT objects
  (setq c1 (make-counter 0))
  (setq c2 (make-counter 10))

  (print (format "c1: %d" (funcall c1))) ;; 1
  (print (format "c2: %d" (funcall c2))) ;; 11
  (print (format "c1: %d" (funcall c1))) ;; 2 (Proves c1 has its own history)
#+END_SRC

** Visualizing the Environment (ASCII)

When we define ~c1~:
1. ~make-counter~ creates a Frame (let's call it E1) where ~n: 0~.
2. The lambda returned points to E1.
3. ~c1~ holds this lambda.

When we define ~c2~:
1. ~make-counter~ runs again, creating a *different* Frame (E2) where ~n: 10~.
2. The lambda returned points to E2.

Since ~c1~ points to E1 and ~c2~ points to E2, changing ~n~ in one
does not affect the other. This is *Encapsulation*.

* The Benefit (Modularity)
:PROPERTIES:
:CUSTOM_ID: monte-carlo
:END:

If assignment is so "bad" (kills substitution), why use it?
*Answer:* It helps us decompose problems.

*Example: Monte Carlo Simulation (Cesaro's Formula)* We want to
estimate $\pi$ using the fact that the probability of two random
integers having a GCD of 1 is $6/\pi^2$.

** Approach A: Functional (Without Assignment)
We would have to pass the random seed (state) into every function, and
return the new seed from every function.
- ~rand(old-seed) -> (new-value, new-seed)~
- ~cesaro(n, old-seed) -> (result, new-seed)~
- ~monte-carlo(trials, old-seed) -> ...~

This "leaks" the implementation detail (random numbers) into the
high-level math code.

** Approach B: Imperative (With Assignment)
We hide the seed inside a ~rand~ function. The math functions just
call ~(rand)~.

#+BEGIN_SRC elisp :results output
  ;; 1. The Random Number Generator (Encapsulated State)
  ;; We use a closure to hide 'x' (the seed)
  (setq rand
        (let ((x 1))
          (lambda ()
            (setq x (mod (* x 16807) 2147483647))
            x)))

  ;; 2. Cesaro's Experiment (The Math)
  ;; Note: GCD is built-in to Emacs 26+, or cl-lib.
  ;; We'll use a simple recursive GCD here just in case.
  (defun my-gcd (a b)
    (if (= b 0) a (my-gcd b (mod a b))))

  (defun cesaro-test ()
    (= (my-gcd (funcall rand) (funcall rand)) 1))

  ;; 3. Monte Carlo Solver (Generic)
  (defun monte-carlo (trials experiment)
    (let ((passed 0))
      (dotimes (i trials)
        (if (funcall experiment)
            (setq passed (1+ passed))))
      ;; Return probability (float)
      (/ (float passed) trials)))

  ;; 4. Estimate Pi
  (defun estimate-pi (trials)
    (sqrt (/ 6.0 (monte-carlo trials 'cesaro-test))))

  ;; Run it!
  (print (format "Pi Estimate (1000 trials): %f" (estimate-pi 1000)))
#+END_SRC

#+RESULTS:
: "Pi Estimate (1000 trials): 3.136250"

*Takeaway:* The ~monte-carlo~ function is beautiful and clean. It
doesn't know about "random seeds" or "state". It just runs an
experiment. This modularity is why we accept the complexity of
assignment.

* Pitfalls of Assignment
:PROPERTIES:
:CUSTOM_ID: pitfalls
:END:

Sussman warns that assignment brings bugs that simply couldn't exist
before:

  1. *Aliasing:* If two variables point to the same object (the same
     environment frame), changing one changes the other. This acts
     like "action at a distance" or "voodoo dolls".
  2. *Order of Evaluation:* In functional math, $a + b$ is the same
     regardless of whether you calculate $a$ or $b$ first. In
     imperative code, if computing $a$ changes a global variable that
     $b$ reads, the order matters immensely.

* Summary
1. *Assignment (~set!~ / ~setq~)* allows us to model objects with local
   state.
2. *The Environment Model* (Frames and Bindings) replaces the
   Substitution Model.
3. *Closures* (Lambdas capturing their environment) are the mechanism
   for Encapsulation.
4. We trade *referential transparency* (easy reasoning) for *modularity*
   (hiding implementation details like random seeds).
