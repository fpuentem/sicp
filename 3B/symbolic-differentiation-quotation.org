#+TITLE: Lecture 3B: Symbolic Differentiation & Quotation (SICP)
#+AUTHOR: Fabricio Puente M.
#+DATE: <2025-11-29 Sat>
#+STARTUP: indent
#+URL: https://youtu.be/bV87UzKMRtE?si=Df87ykdP3x2uSS8X

* Quotation: The Concept

The lecture introduces the concept of *quotation* to solve the problem of distinguishing a *name* (variable) from the *thing it names* (value).

- *"Say your name"* \rightarrow "Fabricio" (Evaluating the command)
- *"Say 'your name'"* \rightarrow "your name" (Quoting the phrase)

In Lisp, this distinction is critical because our data (algebraic expressions like ~(+ x 3)~) looks exactly /like/ our code.

** Code: Quote in Elisp

In Elisp, the single quote character ='= is a shorthand for the special form ~(quote ...)~.

#+BEGIN_SRC elisp :results output
  (defvar a 10)

  ;; 1. Evaluation: Lisp looks up the value of 'a'
  (print a)     ; => 10

  ;; 2. Quotation: Lisp returns the symbol 'a' itself
  (print 'a)    ; => a
  (print (quote a)) ; => a

  ;; 3. Lists: Data vs Function Call
  ;; (print (+ 1 2))   ; Evaluation: calls + function => 3
  ;; (print '(+ 1 2))  ; Quotation: returns list (+ 1 2)
#+END_SRC

* The Differentiation Program (~deriv~)

The goal is to implement the rules of calculus for finding derivatives.

The algorithm is a recursive reduction:

1. $dc/dx = 0$
2. $dx/dx = 1$
3. $d(u+v)/dx = du/dx + dv/dx$
4. $d(uv)/dx = u(dv/dx) + v(du/dx)$

** The Dispatch Function (~deriv~)

This function assumes we have a data abstraction layer (selectors and predicates) defined later. This separates the *logic* of differentiation from the *representation* of the algebra.

#+BEGIN_SRC elisp
  (defun deriv (exp var)
    "Derive expression EXP with respect to variable VAR."
    (cond ((numberp exp) 0)
          ((variable-p exp)
           (if (same-variable-p exp var) 1 0))
          ((sum-p exp)
           (make-sum (deriv (addend exp) var)
                     (deriv (augend exp) var)))
          ((product-p exp)
           (make-sum
            (make-product (multiplier exp)
                          (deriv (multiplicand exp) var))
            (make-product (deriv (multiplier exp) var)
                          (multiplicand exp))))
          (t (error "Unknown expression type -- DERIV: %s" exp))))
#+END_SRC

* Data Abstraction Layer

Here we implement the primitives. The "Pun" mentioned in the lecture is using Lisp lists to represent algebraic expressions directly.

- Algebra: $ax + b$
- Lisp Data: ~(+ (* a x) b)~

This saves us from writing a parser!

** Primitives implementation

We map Scheme concepts to Elisp:

- ~number?~ \rightarrow ~numberp~
- ~symbol?~ \rightarrow ~symbolp~
- ~eq?~ \rightarrow ~eq~
- ~car~, ~cdr~ work the same.

#+BEGIN_SRC elisp
  (defun variable-p (x)
    "Is X a variable? (represented as a symbol)"
    (symbolp x))

  (defun same-variable-p (v1 v2)
    "Are V1 and V2 the same variable?"
    (and (variable-p v1) (variable-p v2) (eq v1 v2)))

  ;; Sums are lists starting with the symbol '+
  (defun sum-p (x)
    (and (listp x) (eq (car x) '+)))

  (defun addend (s) (nth 1 s)) ; Second element
  (defun augend (s) (nth 2 s)) ; Third element

  ;; Products are lists starting with the symbol '*
  (defun product-p (x)
    (and (listp x) (eq (car x) '*)))

  (defun multiplier (p) (nth 1 p))
  (defun multiplicand (p) (nth 2 p))
#+END_SRC

** Naive Constructors

Initially, the constructors just build lists.

#+BEGIN_SRC elisp
  (defun make-sum (a1 a2) (list '+ a1 a2))
  (defun make-product (m1 m2) (list '* m1 m2))
#+END_SRC

** Test Run (Naive)

#+BEGIN_SRC elisp :results output
  ;; d(x + 3) / dx
  (print (deriv '(+ x 3) 'x))
  ;; Output: (+ 1 0) -> Correct but ugly

  ;; d(x * y) / dx
  (print (deriv '(* x y) 'x))
  ;; Output: (+ (* x 0) (* 1 y)) -> Correct but very ugly
#+END_SRC

* Simplification

The "naive" output includes things like ~(+ x 0)~ or ~(* x 1)~. We can fix this by making the *constructors* smarter. They shouldn't just build lists; they should check if the expression can be simplified immediately.

** Smart Constructors

We update ~make-sum~ and ~make-product~ to handle 0 and 1 logic.

#+BEGIN_SRC elisp
  (defun make-sum (a1 a2)
    (cond ((and (numberp a1) (eq a1 0)) a2)      ; 0 + y = y
          ((and (numberp a2) (eq a2 0)) a1)      ; x + 0 = x
          ((and (numberp a1) (numberp a2)) (+ a1 a2)) ; 1 + 2 = 3
          (t (list '+ a1 a2))))

  (defun make-product (m1 m2)
    (cond ((or (and (numberp m1) (eq m1 0))      ; 0 * y = 0
               (and (numberp m2) (eq m2 0))) 0)  ; x * 0 = 0
          ((and (numberp m1) (eq m1 1)) m2)      ; 1 * y = y
          ((and (numberp m2) (eq m2 1)) m1)      ; x * 1 = x
          ((and (numberp m1) (numberp m2)) (* m1 m2)) ; 2 * 3 = 6
          (t (list '* m1 m2))))
#+END_SRC

** Test Run (Simplified)

#+BEGIN_SRC elisp :results output
  ;; d(x + 3) / dx
  (print (deriv '(+ x 3) 'x))
  ;; Output: 1

  ;; d(x * y) / dx
  (print (deriv '(* x y) 'x))
  ;; Output: y

  ;; d(ax + b) / dx
  (print (deriv '(+ (* a x) b) 'x))
  ;; Output: a
#+END_SRC

* Key Takeaways

1.  *Barrier of Abstraction:* The ~deriv~ function didn't change at all when we added simplification. We only changed the *constructors* (~make-sum~, ~make-product~). ~deriv~ just calls them.
2.  *Expression Representation:* By using the same format for our data (lists) as Lisp does for code, we gain powerful manipulation capabilities easily.
3.  *Recursive Reduction:* The differentiation rules naturally fit a recursive structure that breaks expressions down to their atomic parts (numbers and variables).
